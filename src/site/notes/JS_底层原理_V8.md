---
{"dg-publish":true,"permalink":"/JS_底层原理_V8/"}
---

#review  


**1. JavaScript 引擎 (以 V8 为例)**
*   **是什么？** JavaScript 本身是一种脚本语言规范（ECMAScript）。要让计算机执行 JS 代码，就需要一个“翻译官”+“执行者”，这就是 JavaScript 引擎。==V8 是由 Google 开发的高性能开源 JavaScript 和 WebAssembly 引擎，用 C++ 编写，是 Chrome 浏览器和 Node.js 的核心部分==。其他引擎还有 SpiderMonkey (Firefox), JavaScriptCore (Safari)。
*   **核心任务：** ==将你写的 JavaScript 代码转换成计算机能直接运行的机器码==。
*   **关键组成部分 (简化理解):**
    *   **解析器 (Parser):** 读取 JS 代码，进行词法分析（将代码分解成 token）和语法分析（构建抽象语法树 AST），检查语法错误。 [[JS_底层原理_词法分析 & 语法分析\|JS_底层原理_词法分析 & 语法分析]]
    *   **编译器 (Compiler) / 解释器 (Interpreter):** 这是 V8 的亮点。它采用 **即时编译 (JIT - Just-In-Time Compilation)** 策略。
        *   **Ignition (解释器):** 首先，Ignition 将 ==AST 转换为字节码==（一种中间代码）。解释器逐行执行字节码。这个启动速度快，但执行效率相对较低。
        *   **TurboFan (优化编译器):** ==V8 会监控代码的执行情况==。如果某段代码（比如一个函数）被频繁执行（称为“==热点代码==”），TurboFan 会介入，==将这段代码的字节码编译成高度优化的机器码。==这个编译过程本身需要时间，但一旦完成，执行速度会非常快。
        *   **反优化 (Deoptimization):** 如果后续代码执行情况发生变化（例如，函数参数类型改变），导致之前的优化假设不再成立，V8 会丢弃优化后的机器码，==回退到执行字节码或重新进行优化==。
    *   **内存堆 (Memory Heap):** 用于存储对象、数组等引用类型的数据。内存分配和垃圾回收 (Garbage Collection, GC) 发生在这里。理解 GC 对避免内存泄漏很重要。[[JS_底层原理_垃圾回收机制\|JS_底层原理_垃圾回收机制]]
    *   **调用栈 (Call Stack):** 用于跟踪函数的调用关系。当一个函数被调用时，它的执行上下文（包含局部变量、`this` 指向等信息）会被创建并推入栈顶。当函数执行完毕返回时，其上下文会从栈顶弹出。**调用栈是同步执行的，后进先出 (LIFO)。**
<!--SR:!2025-04-16,3,250!2025-04-16,3,250!2025-04-16,3,250!2025-04-16,3,250!2025-04-16,3,250!2025-04-16,3,250!2025-04-16,3,250-->

*   **V8 与单线程:** ==V8 执行 JavaScript 代码是在**单个调用栈**上进行的。这意味着在任何给定时刻，V8 只能执行一段同步代码==。如果这段代码耗时很长（例如一个复杂的 `for` 循环计算），它就会**阻塞调用栈**。
<!--SR:!2025-04-16,3,250-->

**2. 浏览器/Node.js 运行时环境 (Runtime Environment)**

*   **V8 不是全部：** V8 引擎本身只负责执行 JavaScript 代码。但是，我们在浏览器或 Node.js 中使用的很多功能，如 `setTimeout`, `DOM 操作`, `XMLHttpRequest`/`fetch`, `事件监听 (click, scroll)` 等，**并不是由 V8 直接提供的**。
*   **宿主环境提供：** 这些功能是由 JavaScript 的**宿主环境**（浏览器或 Node.js）提供的，通常称为 **Web APIs** (在浏览器中) 或 **Node.js APIs**。这些 API 通常是用 C++ 等语言实现的，==并且**可以在 V8 主线程之外执行**（例如，网络请求、定时器计时）==。

**3. 事件循环 (Event Loop)**

*   **目的：** 解决 JavaScript 单线程（V8 调用栈）执行与异步、非阻塞 I/O 操作（由宿主环境 API 提供）之间的协调问题。它是一种**调度机制**。
*   **核心组件：**
    *   **调用栈 (Call Stack):** V8 在这里同步执行 JS 代码。
    *   **Web APIs / Node.js APIs:** 宿主环境提供的异步功能。当 JS 调用这些 API（如 `setTimeout(callback, 1000)`）时，V8 将任务交给对应的 API，然后 V8 *继续* 执行调用栈中的下一条指令（不会等待 API 完成）。
    *   **任务队列 (Task Queue / Macrotask Queue):** 当 Web API 完成其任务（例如，定时器时间到、网络请求返回、用户点击按钮）并且需要执行对应的回调函数时，这个回调函数会被放入任务队列中排队。
    *   **微任务队列 (Microtask Queue):** 优先级更高的队列，主要存放 `Promise.then/catch/finally` 的回调、`MutationObserver` 的回调、`queueMicrotask()` 的回调。 [[JS_底层原理_事件循环_MutationObserver & queueMicrotask\|JS_底层原理_事件循环_MutationObserver & queueMicrotask]]
*   **循环过程 (简化版):**
    1.  查看调用栈，执行栈中的所有同步代码。
    2.  当调用栈为空时，去检查**微任务队列**。
    3.  如果微任务队列不为空，则依次执行队列中的所有微任务，直到微任务队列变空。如果在执行微任务的过程中又产生了新的微任务，会继续添加到队列末尾并在当前循环中执行完。
    4.  **（浏览器环境特有）** 进行 UI 渲染检查。浏览器判断是否需要并且有时间进行页面渲染（Style, Layout, Paint）。这步不是每次事件循环都发生。`requestAnimationFrame` 的回调会在这里之前执行。
    5.  去检查**任务队列 (宏任务)**。
    6.  如果任务队列不为空，取出一个任务（最老的那个），将其回调函数放入调用栈中执行。
    7.  回到步骤 1（或步骤 2，取决于具体实现细节和是否有新的同步代码）。

**V8 和事件循环的关系**

*   **V8 是“运动员”:** 它负责实际执行 JavaScript 代码（跑）。
*   **事件循环是“调度员/裁判”:** 它决定 V8 *何时* 执行 *哪个* 代码片段（何时上场跑步，跑哪段赛道）。
*   **宿主环境是“场地和辅助设施”:** 提供 Web APIs（赛道旁的计时器、水站等），并将完成信号（运动员跑完特定赛段）通知给调度员（将回调放入队列）。

**底层原理对我实际场景应用的影响**

理解 V8 和事件循环如何协同工作，直接关系到你如何编写高效、流畅的前端应用：

1.  **避免阻塞主线程：**
    *   **场景：** 大数据计算、复杂循环。
    *   **原理：** V8 的调用栈是同步阻塞的。长时间运行的同步代码会卡住调用栈，阻止事件循环继续进行，导致页面无法渲染、无法响应用户操作。
    *   **应用：**
        *   使用 `setTimeout(fn, 0)` 将长任务拆分成小块，每次执行一小块后，将下一块的处理放入**任务队列**，让事件循环有机会执行其他任务（包括渲染）。
        *   使用 `Web Worker` 将计算密集型任务放到**后台线程**（有独立的 V8 实例和事件循环），彻底解放主线程。主线程通过异步消息与 Worker 通信（消息回调进入主线程的任务队列）。

2.  **理解异步操作的时序：**
    *   **场景：** `fetch` 数据后更新 UI、`setTimeout` 延迟执行。
    *   **原理：** `fetch`、`setTimeout` 的回调函数会被放入**任务队列 (宏任务)**，而 `Promise.then` 的回调会被放入**微任务队列**。微任务总是在下一个宏任务执行之前、并且在当前同步代码执行完毕后立即执行。
    *   **应用：** 能准确预测代码执行顺序，尤其是在混合使用 `Promise` 和 `setTimeout` 时。知道 `Promise.resolve().then(callback)` 会比 `setTimeout(callback, 0)` 更早执行。这对于依赖精确时序的逻辑很重要。

3.  **优化动画和渲染：**
    *   **场景：** 实现平滑的 JavaScript 动画。
    *   **原理：** `requestAnimationFrame` 的回调被安排在浏览器**渲染之前**执行，与显示器刷新率同步。而 `setTimeout`/`setInterval` 的回调执行时机与渲染不同步，可能导致丢帧或卡顿。
    *   **应用：** 优先使用 `requestAnimationFrame` 来执行每一帧的动画更新逻辑，保证动画平滑。理解这一点就知道为什么 rAF 比 `setInterval` 做动画效果更好。

4.  **理解 `IntersectionObserver` 的高效：**
    *   **场景：** 图片懒加载、无限滚动。
    *   **原理：** `IntersectionObserver` ==利用了浏览器底层优化的机制来检测交叉状态==，其回调是异步触发并放入**任务队列**的。它避免了在 `scroll` 事件监听中频繁进行昂贵的 `getBoundingClientRect()` 计算和判断，减少了主线程负担。
    *   **应用：** 在需要基于元素可见性执行操作时，优先选择 `IntersectionObserver` 而不是高频的 `scroll` 事件监听 + 手动计算。
<!--SR:!2025-04-16,3,250-->

**需要知道的关键底层原理总结：**

1.  **JS 单线程执行模型 (主线程):** V8 在调用栈上同步执行代码。
2.  **V8 JIT 编译:** 解释器快速启动，优化编译器提升热点代码性能。
3.  **宿主环境提供异步 API:** `setTimeout`, `fetch`, DOM 事件等不是 V8 核心功能。
4.  **事件循环机制:** 协调同步代码、异步 API 回调、微任务、宏任务和渲染的调度中心。
5.  **宏任务 vs 微任务:** 微任务优先级更高，会在当前同步代码执行完后、下一个宏任务执行前全部清空。
6.  **渲染时机:** 渲染发生在事件循环的特定阶段（通常在微任务之后），`requestAnimationFrame` 与此紧密相关。
7.  **阻塞的影响:** 长时间同步代码会阻塞调用栈，进而阻塞事件循环，导致页面无响应。

