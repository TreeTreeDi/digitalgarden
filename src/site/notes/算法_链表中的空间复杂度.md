---
{"dg-publish":true,"permalink":"/算法_链表中的空间复杂度/"}
---


**空间复杂度**通常指的是算法运行过程中**额外**使用的内存空间，这个空间不包括存储输入数据本身所需的空间。我们关注的是算法为了完成计算所临时或永久分配的、并且其大小**依赖于输入规模**的内存。

==在这个特定的分隔链表算法中，我们来审视一下使用了哪些变量和内存：==

1.  **哑节点 (Dummy Nodes):**
    *   `smallDummy`: 创建了一个 `ListNode` 对象。
    *   `bigDummy`: 创建了另一个 `ListNode` 对象。
    *   **分析**: 这两个节点的创建是固定的，无论输入的链表有多长（有多少个节点 N），我们始终**只创建这两个**哑节点。它们的数量不随 N 的增长而增长。

2.  **尾指针 (Tail Pointers):**
    *   `smallTail`: 一个指向 `ListNode` 的指针（引用）。
    *   `bigTail`: 另一个指向 `ListNode` 的指针（引用）。
    *   **分析**: 这两个指针变量本身占用的内存是固定的（通常是 4 或 8 字节，取决于系统架构）。它们的数量也是固定的（2个），不随 N 变化。

3.  **遍历指针 (Iteration Pointer):**
    *   `node`: 一个在原始链表上移动的指针。
    *   `nextNode`: 一个临时保存 `node.next` 的指针，在循环内部使用。
    *   **分析**: 这两个指针变量同样占用固定的内存空间，数量也是固定的，不随 N 变化。

4.  **链表节点本身:**
    *   **关键点**: 算法**没有创建任何新的数据节点**来存储原始链表中的值。它做的**仅仅是**将**原始链表中的节点**（即输入 `head` 指向的链表中的那些节点）从原有的连接关系中解开，然后重新连接到 `small` 链表或 `big` 链表的尾部。
    *   **分析**: 我们是在**复用 (reuse)** 输入链表的节点。算法的核心在于修改这些**现有节点**的 `next` 指针，将它们重新组织成两个部分，最后再连接起来。内存消耗主要来自这些节点本身，但这部分内存是**输入数据**占用的空间，不计入额外空间复杂度。

**总结:**

算法使用的**额外**空间主要就是固定的几个变量：两个哑节点（`ListNode` 对象）和几个指针（`smallTail`, `bigTail`, `node`, `nextNode`）。这些变量的数量和大小是**常数**级别的，它们**不**会因为输入链表的长度 N 变大而增加。

因此，无论输入链表有 10 个节点还是 1,000,000 个节点，该算法所需要的**额外**内存空间（除了输入数据本身）几乎是恒定的。这就是为什么我们说这个算法的空间复杂度是 **O(1)**（常数空间复杂度）。