---
{"dg-publish":true,"permalink":"/算法_链表/"}
---



| **问题特征/目标**           | **常用方法/技巧**                             | **关键考量**                                     | **示例题目 (LeetCode)**                        |
| --------------------- | --------------------------------------- | -------------------------------------------- | ------------------------------------------ |
| **保持相对顺序** 的分隔/分组     | **双指针 + 哑节点** (构建多个逻辑链表再合并)             | 尾插法保持顺序, O(1) 额外空间                           | 86. 分隔链表, 328. 奇偶链表                        |
| 查找中间节点 / 判断环 / 找环入口   | **快慢指针**                                | 速度差导致相遇或定位                                   | 876. 链表的中间结点, 141. 环形链表 I, 142. 环形链表 II    |
| 查找倒数第 k 个节点           | **快慢指针** (快指针先走 k 步) 或 **两次遍历**         | 快慢指针一次遍历 O(N) 时间, O(1) 空间                    | 19. 删除链表的倒数第 N 个结点                         |
| **反转**整个或部分链表         | **迭代 (三指针: prev, curr, next)** 或 **递归** | 迭代 O(1) 空间, 递归 O(N) 栈空间 (取决于深度)              | 206. 反转链表, 92. 反转链表 II [[算法_链表_反转链表的三个指标\|算法_链表_反转链表的三个指标]] |
| **合并**两个**有序**链表      | **迭代 (双指针 + 哑节点)** 或 **递归**             | 比较节点值, 链接较小者                                 | 21. 合并两个有序链表                               |
| **删除**节点 (给定节点指针)     | 修改前一个节点的 `next` 指向 (需要找到前一个节点)          | 如果只给当前节点指针且非尾节点, 可用值覆盖+删后面                   | 237. 删除链表中的节点 (特殊情况)                       |
| **删除**满足条件的节点 (如重复元素) | **迭代 + 指针** (可能需要哑节点处理头节点)              | 对于有序列表去重简单, 无序列表可能需哈希表                       | 83. 删除排序链表中的重复元素, 82. 删除排序链表中的重复元素 II      |
| 链表**排序**              | **归并排序** (常用, 分割+合并) 或 **插入排序**         | 归并 O(N log N) 时间, O(log N) 递归空间或 O(1) 迭代空间   | 148. 排序链表, 147. 对链表进行插入排序                  |
| 判断两个链表是否**相交** / 找交点  | **哈希表** 或 **双指针** (长度对齐技巧)              | 哈希表 O(M+N) 时间 O(M) 空间, 双指针 O(M+N) 时间 O(1) 空间 | 160. 相交链表                                  |
| 需要快速检查值/节点**是否存在**    | **哈希表**                                 | 空间换时间                                        | 141. 环形链表 I (用哈希表也可做)                      |

**链表学习路径 (由浅入深)**

1.  **基础操作与指针技巧入门**
    *   **合并两个有序链表 (Merge Two Sorted Lists)**
        *   难度：简单
        *   核心：基本的指针移动、比较、新链表构建。这是链表最基础的操作之一。
        *   链接：[https://leetcode.cn/problems/merge-two-sorted-lists/](https://leetcode.cn/problems/merge-two-sorted-lists/)

[[算法_链表_理解 dummy 的应用 & 快慢指针_倒数链表第 N 个节点\|算法_链表_理解 dummy 的应用 & 快慢指针_倒数链表第 N 个节点]]

  **删除排序链表中的重复元素 II (Remove Duplicates from Sorted List II)**
        *   难度：中等
        *   核心：更复杂的指针操作，需要处理多个重复元素和边界情况，建立虚拟头节点（Dummy Node）是个好技巧。
        *   链接：[https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

[[算法_链表_反转和旋转\|算法_链表_反转和旋转]]

3.  **特殊技巧与综合应用**
    *   **环形链表 (Linked List Cycle)**
        *   难度：简单
        *   核心：快慢指针检测环。这是链表中一个非常经典的技巧。我们稍后会详细讲解。
        *   链接：[https://leetcode.cn/problems/linked-list-cycle/](https://leetcode.cn/problems/linked-list-cycle/)
    [[算法_链表_特定顺序的双链表 & 尾插法_分割链表\|算法_链表_特定顺序的双链表 & 尾插法_分割链表]]
    *   **两数相加 (Add Two Numbers)**
        *   难度：中等
        *   核心：模拟竖式加法，注意进位处理和链表长度不一致的情况。
        *   链接：[https://leetcode.cn/problems/add-two-numbers/](https://leetcode.cn/problems/add-two-numbers/)
    [[算法_链表_Hash表在两次遍历中的应用_随机链表的复制\|算法_链表_Hash表在两次遍历中的应用_随机链表的复制]]

4.  **高阶挑战与实际应用**
    *   **K 个一组翻转链表 (Reverse Nodes in k-Group)**
        *   难度：困难
        *   核心：链表操作的集大成者，结合了分组、反转、递归/迭代，对指针操作要求极高。
        *   链接：[https://leetcode.cn/problems/reverse-nodes-in-k-group/](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
    *   **LRU 缓存 (LRU Cache)**
        *   难度：中等
        *   核心：数据结构设计题。结合哈希表（快速查找）和双向链表（快速增删、维护顺序）实现 LRU 策略。
        *   链接：[https://leetcode.cn/problems/lru-cache/](https://leetcode.cn/problems/lru-cache/)

**知识点关联与进阶理解**

*   **指针操作是核心**: 链表的所有操作都围绕指针（`next`, `prev`，有时还有 `random`）的移动、指向改变来完成。熟练掌握指针操作是根本。
*   **虚拟头节点 (Dummy Node)**: 在很多链表操作（如插入、删除、合并）中，引入一个虚拟头节点可以极大地简化边界条件的处理（比如在头节点前插入，或删除头节点）。上面的 `删除排序链表中的重复元素 II` 和 `合并两个有序链表` 等题目都可以用这个技巧。
*   **快慢指针**: 这是链表中非常强大的技巧。
    *   找中点：慢指针走一步，快指针走两步，快指针到终点时慢指针在中点。
    *   判环：慢指针走一步，快指针走两步，如果相遇则有环 (`环形链表`)。
    *   找倒数第 K 个节点：快指针先走 K 步，然后快慢指针一起走，快指针到终点时慢指针在倒数第 K 个节点 (`删除链表的倒数第 N 个结点`)。
*   **链表反转**: 这是一个基本但重要的操作，`反转链表 II` 和 `K 个一组翻转链表` 都需要用到反转的思想。掌握迭代和递归两种反转方式。
*   **==链表成环与断开==**: 在 `旋转链表` 和 `环形链表` 相关问题（如找到环的入口点）中会用到。
*   **哈希表辅助**: 在 `随机链表的复制` 和 `LRU 缓存` 中，哈希表可以用来快速查找节点，优化时间复杂度。
*   **双向链表**: `LRU 缓存` 通常使用双向链表，因为它支持 O(1) 时间复杂度的节点删除（知道节点地址的情况下）和插入。

