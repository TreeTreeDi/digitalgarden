---
{"dg-publish":true,"permalink":"/算法_数组_前后缀/"}
---




### 分步拆解：为什么必须用前后缀？

#### 1. 问题限制条件分析

- **禁止除法**：遇到0元素会导致计算错误（如 [0,1,2]）
- **O(n)时间要求**：排除O(n²)暴力解法
- **空间限制**：最优解要求O(1)额外空间（输出数组不算）

#### 2. 核心矛盾点

==每个元素的结果 = 左边所有元素乘积 × 右边所有元素乘积  ==
==但直接计算每个元素的左右乘积会导致重复计算==，时间复杂度爆炸。

#### 3. 前后缀如何化解矛盾

通过**==空间换时间==**，预存每个位置的左右乘积：

- **前缀数组**：`pre[i] = nums[0]×nums[1]×...×nums[i-1]`
- **后缀数组**：`suf[i] = nums[i+1]×...×nums[n-1]`

这样每个元素的结果只需一次乘法：`res[i] = pre[i] × suf[i]`


解法

1. **计算前缀和**：在遍历数组的同时累加
2. **查找差值**：寻找满足特定条件的前缀和差值
3. **空间优化**：通常可以使用哈希表或滑动窗口优化空间复杂度

[238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

[[53. 最大子数组和\|53. 最大子数组和]] => 前缀和 前缀 - 最小前缀 = 当前最大的连续子数组和

滑动窗口实质上是一种在线处理的前缀和优化技术 => [[209 长度最小的子数组\|209 长度最小的子数组]]